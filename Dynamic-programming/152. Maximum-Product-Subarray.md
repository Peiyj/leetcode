## Link To The Problem 
https://leetcode.com/problems/maximum-product-subarray/

## Problem Description

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

## Ideas

At each sub program, we keep track of the maximum positive value and 

## Algorithm Analysis

This is a generic algorithm to solve backtracking problem
```py
def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        output = []
        nums.sort() 
        self.backtrack(output, [], nums)
        return output
def backtrack(self, output, tempList, nums):
    if len(tempList) == len(nums):
        output.append(list(tempList))
    else:
        for i in range(len(nums)):
            if nums[i] in tempList:
                continue # element already exists, skip
            tempList.append(nums[i]) 
            self.backtrack(output, tempList, nums)
            tempList.pop() 
```

## Code

```py
class Solution(object):
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        maxPos = [0] * len(nums)
        maxNeg = [0] * len(nums)
        
        maxPos[0] = max(nums[0], 0)
        maxNeg[0] = min(nums[0], 0)
        
        for i in range(1, len(nums)):
            maxPos[i] = max(0, maxPos[i-1] * nums[i], maxNeg[i-1] * nums[i], nums[i])
            maxNeg[i] = min(0, maxNeg[i-1] * nums[i], maxPos[i-1] * nums[i], nums[i])
        return max(maxPos)
        
```

## Complexity Analysis
```
This analysis out of the scope
```
## Related Topics
```String``` ```Backtracking```




